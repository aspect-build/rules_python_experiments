"""Declare runtime dependencies

These are needed for local dev, and users must install them as well.
See https://docs.bazel.build/versions/main/skylark/deploying.html#dependencies
"""

load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
load("//python/private:toolchains_repo.bzl", "PLATFORMS", "toolchains_repo")
load("//python/private:versions.bzl", "MINOR_MAPPING", "RELEASE_DATE", "RELEASE_URL", "TOOL_VERSIONS")

# WARNING: any changes in this function may be BREAKING CHANGES for users
# because we'll fetch a dependency which may be different from one that
# they were previously fetching later in their WORKSPACE setup, and now
# ours took precedence. Such breakages are challenging for users, so any
# changes in this function should be marked as BREAKING in the commit message
# and released only in semver majors.
def rules_python_experiments_dependencies():
    # The minimal version of bazel_skylib we require
    maybe(
        http_archive,
        name = "bazel_skylib",
        sha256 = "c6966ec828da198c5d9adbaa94c05e3a1c7f21bd012a0b29ba8ddbccb2c93b0d",
        urls = [
            "https://github.com/bazelbuild/bazel-skylib/releases/download/1.1.1/bazel-skylib-1.1.1.tar.gz",
            "https://mirror.bazel.build/github.com/bazelbuild/bazel-skylib/releases/download/1.1.1/bazel-skylib-1.1.1.tar.gz",
        ],
    )

########
# Remaining content of the file is only used to support toolchains.
########
PYTHON_VERSIONS = TOOL_VERSIONS.keys() + MINOR_MAPPING.keys()

_DOC = "Fetch external tools needed for python toolchain"
_ATTRS = {
    "python_versions": attr.string_list(mandatory = True),
    "default_python_version": attr.string(values = PYTHON_VERSIONS),
    "platform": attr.string(mandatory = True, values = PLATFORMS.keys()),
}

def _desugar_python_version(v):
    if v not in PYTHON_VERSIONS:
        fail("Python version '%s' is not supported, expected on of %s" % (v, str(", ".join(PYTHON_VERSIONS))))
    return v if v not in MINOR_MAPPING else MINOR_MAPPING[v]

def _python_repo_impl(rctx):
    versions = [_desugar_python_version(v) for v in rctx.attr.python_versions]

    if not rctx.attr.default_python_version:
        default_python_version = versions[0]
    else:
        default_python_version = _desugar_python_version(rctx.attr.default_python_version)

    interpreters = {}

    for version in versions:
        release_filename = "cpython-{version}-{platform}-pgo+lto-{release_date}.tar.zst".format(
            release_date = RELEASE_DATE,
            version = version,
            platform = rctx.attr.platform,
        )
        url = "{release_url}/{release_filename}".format(
            release_url = RELEASE_URL,
            release_filename = release_filename,
        )
        rctx.download(
            url = url,
            integrity = TOOL_VERSIONS[version][rctx.attr.platform],
            output = release_filename,
        )
        unzstd = rctx.which("unzstd")
        if not unzstd:
            fail("Missing unzstd: please install zstd https://github.com/facebook/zstd")

        pkg = "py%s" % version
        base = "./%s" % pkg

        rctx.execute(["mkdir", base])
        exec_result = rctx.execute([
            "tar",
            "--directory={}".format(base),
            "--extract",
            "--strip-components=2",
            "--use-compress-program=unzstd",
            "--file={}".format(release_filename),
        ])

        if exec_result.return_code:
            fail(exec_result.stderr)

        build_content = """\
# Generated by python/repositories.bzl

load("@aspect_rules_python_experiments//python/private:py_interpreter.bzl", "py_interpreter")

filegroup(
    name = "files",
    srcs = glob(
        ["bin/**", "lib/**", "include/**", "share/**"],
        exclude = ["**/* *", "**/RECORD"]
    ),
)

exports_files(
    ["bin/python3", "bin/pip3"],
    visibility = ["//visibility:public"],
)

py_interpreter(
    name = "python_interpreter_v{version}",
    version = "@aspect_rules_python_experiments//python/private:v{version}",
    interpreter = "bin/python3",
    pip = "bin/pip3",
    files = [":files"],
    visibility = ["//visibility:public"],
)

# Make it easier to run the interpreter from a bazel run
alias(
    name = "{pkg}",
    actual = ":python_interpreter_v{version}",
)

filegroup(
    name = "venv_bin_files",
    srcs = [":python_interpreter_v{version}"],
    output_group = "venv_bin",
)

sh_binary(
    name = "venv",
    srcs = [":venv_bin_files"],
)

filegroup(
    name = "pip_bin_files",
    srcs = [":python_interpreter_v{version}"],
    output_group = "pip_bin",
)

sh_binary(
    name = "pip",
    srcs = [":pip_bin_files"],
)

py_runtime(
    name = "py3_runtime_native",
    interpreter = "bin/python3",
    files = [":files"],
    python_version = "PY3",
    visibility = ["//visibility:public"],
)
    """.format(
            version = version,
            pkg = pkg,
        )

        # Base BUILD file for this repository
        rctx.file("%s/BUILD.bazel" % base, build_content)

        # Add some convenience symlinks to the various versions and allow the 'python' and 'python3' symlinks
        # to take the default version
        python_bin_path = "{base}/bin/python3".format(base = base)
        rctx.symlink(python_bin_path, "python%s" % version)

        if version == default_python_version:
            rctx.symlink(python_bin_path, "python3")
            rctx.symlink(python_bin_path, "python")

        interpreters[version] = struct(
            version = version,
            interpreter_target = "//py{version}:python_interpreter_v{version}".format(
                version = version,
            ),
            runtime_native_target = "//py{version}:py3_runtime_native".format(
                version = version,
            ),
            python_bin_target = "//py{version}:bin/python3".format(
                version = version,
            ),
        )

    if rctx.attr.default_python_version == "":
        if len(versions) != 1:
            fail("default_python_version must be set if defining more than one Python interpreter")
        else:
            default_version = versions[0]
    else:
        default_version = _desugar_python_version(rctx.attr.default_python_version)

    interpreter_targets = "\n\t\t".join([
        "\"%s\"," % v.interpreter_target
        for k, v in interpreters.items()
    ])

    # TODO: also add the native Python toolchain setup here for the default version so it works with the existing rules
    root_build_content = """\
# Generated by python/repositories.bzl

load("@aspect_rules_python_experiments//python/private:py_runtimes.bzl", "py_runtimes")
load("@bazel_tools//tools/python:toolchain.bzl", "py_runtime_pair")

py_runtimes(
    name = "python_runtimes",
    default_version = "@aspect_rules_python_experiments//python/private:v{version}",
    interpreters = [
        {interpreter_targets}
    ],
    visibility = ["//visibility:public"],
)

py_runtime_pair(
    name = "python_runtimes_native",
    py2_runtime = None,
    py3_runtime = "{runtime_native_target}",
)
""".format(
        interpreter_targets = interpreter_targets,
        runtime_native_target = interpreters[default_python_version].runtime_native_target,
        version = default_version,
    )

    rctx.file("BUILD.bazel", root_build_content)

python_repositories = repository_rule(
    _python_repo_impl,
    doc = _DOC,
    attrs = _ATTRS,
)

# Wrapper macro around everything above, this is the primary API
def python_register_toolchains(name, **kwargs):
    """Convenience macro for users which does typical setup.

    - Create a repository for each built-in platform like "python_linux_amd64" -
      this repository is lazily fetched when Python is needed for that platform.
    - TODO: create a convenience repository for the host platform like "python_host".
    - Create a repository exposing toolchains for each platform like "python_platforms".
    - Register a toolchain pointing at each platform.
    Users can avoid this macro and do these steps themselves, if they want more control.
    Args:
        name: base name for all created repos, like "pythons".
        **kwargs: passed to each python_repositories call.
    """
    for platform in PLATFORMS.keys():
        python_repositories(
            name = name + "_" + platform,
            platform = platform,
            **kwargs
        )
        native.register_toolchains("@%s_toolchains//:%s_toolchain" % (name, platform))
        native.register_toolchains("@%s_toolchains//:%s_toolchain_native" % (name, platform))

    toolchains_repo(
        name = name + "_toolchains",
        user_repository_name = name,
    )
